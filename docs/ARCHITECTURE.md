# アーキテクチャ: 分散型 GAS Wiki

## コアコンセプト: "Push型情報交換"
リクエストに応じてデータを「スクレイピング」または「プル」する従来の分散Wikiとは異なり、本システムは **Push/Gossipモデル** を採用します。
ノードは積極的に情報を交換します。ユーザーがページを更新すると、その更新は既知のピア（友人/リレー）に伝播されます。

**インスピレーション:** Mastodon (ActivityPub), Nostr, Scuttlebutt.

### なぜこのアプローチか？
1.  **パフォーマンス**: データは既にローカル（ユーザー自身のノード）にキャッシュされているため、閲覧は即座に行われます。ページ表示中にリモートネットワーク呼び出しを待つ必要はありません。
2.  **耐障害性**: 元の著者のノードが一時的にダウン（クォータ制限、メンテナンスなど）していても、ピアがデータのコピーを持っているため閲覧可能です。
3.  **GASへの適合性**: GASには厳しい実行時間制限があります。リアルタイムで複数のソースからデータを取得するのは遅く、信頼性が低くなります。バックグラウンド同期の方がGASに適しています。

---

## システムコンポーネント

### 1. ノード (個人Wiki)
各ユーザーのGASプロジェクトが1つのノードとなります。
- **ストレージ**: Google Spreadsheet
    - `Pages`: 自分の記事。
    - `Peers`: 信頼/フォローしている他のノード（APIエンドポイントURL）のリスト。
    - `Cache`: ピアから受信した記事のコピー。
- **インターフェース**:
    - `doGet`: Reactフロントエンドを提供。
    - `doPost`: 更新を受信するためのAPIエンドポイント（Inbox）として機能。

### 2. プロトコル (通信フロー)

#### A. 投稿 (Outbox)
ユーザーAがページを作成/更新するとき:
1.  **ローカル保存**: ユーザーAのSpreadsheetに保存。
2.  **ブロードキャスト**: スクリプトが `Peers` リストを反復処理。
3.  **Push**: 各ピアの `doPost` エンドポイントにJSONペイロードを送信。
    ```json
    {
      "type": "UPDATE",
      "payload": {
        "id": "uuid...",
        "title": "Page Title",
        "content": "Markdown content...",
        "updatedAt": "ISO-Timestamp",
        "author": "User A (or Public Key/ID)",
        "origin": "https://script.google.com/..."
      }
    }
    ```

#### B. 受信 (Inbox)
ユーザーBがPOSTリクエストを受信するとき:
1.  **検証**: 送信者が `Peers` リストに含まれているか（またはノードがパブリックに開かれているか）を確認。
2.  **Upsert**: 新しいコンテンツでローカルの `Cache` シートを更新。
3.  **通知**: (オプション) UIまたはメール経由でユーザーBに通知。

### 3. GASの制限への対策

#### クォータとタイムアウト
多数のピアへのHTTPリクエスト送信は時間がかかります。GASスクリプトは6分（またはそれ以下）でタイムアウトします。
- **解決策**: **非同期キューパターン**
    - 即時に送信するのではなく、更新イベントを `Queue` シートに書き込む。
    - **時間主導型トリガー**（例: 10分ごと、または1分ごと）を使用して、キューを処理し、バッチでリクエストを送信する。

#### 同時アクセス
Spreadsheetは行レベルのロックを持つデータベースではありません。
- **解決策**: 書き込み操作中の競合状態を防ぐために、GASの `LockService` を使用する。

---

## 想定ユースケースとセキュリティ

### 1. Google Workspace (企業内利用)
- **シナリオ**: 部署ごと、プロジェクトごとに分散したWikiを緩やかに連携させ、全社的なナレッジベースを構築する。
- **要件**:
    - 社外への情報流出防止（セキュリティ優先）。
    - ドメイン内でのシングルサインオン的体験。
- **認証**: 組織内共通の「共有シークレット」またはアクセス権限設定（Access: Anyone within [Domain]）。

### 2. 個人間・コミュニティ利用 (通常Googleアカウント)
- **シナリオ**: 友人同士、特定トピックの研究者グループなどで、互いのローカルWikiを接続し合う。
- **要件**:
    - スパム防止（知らない人からのデータ混入を防ぐ）。
    - 相互承認プロセス。
- **認証**: ピアごとの「API Key」交換、またはホワイトリスト方式。

## 共通セキュリティ設計
両ユースケースに対応するため、**「Bearer Token認証（共有シークレット）」** を基本プロトコルとします。
- 各ノードは設定で `API_SECRET` を保持する（またはピアごとに発行する）。
- `doPost` リクエスト時に `Authorization: Bearer <SECRET>` ヘッダーを付与する。
- 受信側はトークンを検証し、許可されたピアからの更新のみを受け入れる。

---

## データ構造案

### Peers シート
| URL | Name | Status | LastSynced |
| --- | --- | --- | --- |
| https://script.google.com/.../exec | Kench | Active | 2026-01-16T10:00:00Z |

### Cache シート (外部データ)
| ID | Origin | Title | Content | UpdatedAt | SyncedAt |
| --- | --- | --- | --- | --- | --- |
| uuid-1 | https://... | Remote Page | ... | ... | ... |
